---
title: 12865. 평범한 배낭
date: 2023-01-22 16:37 +/-0900
categories: [PS, boj]
tags: [knapsack]     # TAG names should always be lowercase
---

# 12865. 평범한 배낭

## Problem
[https://www.acmicpc.net/problem/12865](https://www.acmicpc.net/problem/12865){:target="_blank" rel="noopener"}

## Key Idea
- Dynamic Programming을 이용하여 문제를 subproblem으로 나누어라

## Algorithm
- 물품 N개와 가치 K를 저장하는 A\[N+1\]\[K+1\] 의 배열을 만들어라
- W\[i\]는 i번째 물건의 무게, V\[i\]는 i번째 물건의 가치이다
- A\[i\]\[j\]는 i번째 물품까지 고려했을때, 무게를 j만큼 담을 수 있는 배낭의 최대 가치를 나타낸다
- A\[0\]\[j\]는 물건이 항상 없으므로 0, A\[i\]\[0\] 은 배낭에 담을 수 있는 물건이 항상 없으므로 0이다
- 만약 i번째 물품의 무게가 j보다 크다면, 애초에 들어갈수가 없다. 따라서 그 값은 A\[i-1\]\[j\]과 같다
- 그렇지 않다면, 1) i번째 물품을 포함하지 않거나, 2) i번째 물품을 포함할 수 있다
	- 1번 경우: 앞서 구한 A\[i-1\]\[j\]
	- 2번 경우: i번째 물품을 넣게되었다면, i번째 물품의 무게를 제외한 배낭의 최대가치 + i번째 물품의 가치
	  즉, V\[i\] + A\[i-1\]\[j-W\[i\]\]
- 따라서 max(A\[i-1\]\[j\], V\[i\] + A\[i-1\]\[j-W\[i\]\]) 가 된다

- 시간복잡도: $$O(N*K)$$
- 공간복잡도: $$O(N*K)$$
## Code

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>

using namespace std;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cout.tie(NULL);

  int N, K;
  int W, V;

  cin >> N >> K;
  vector<pair<int, int>> bag(N + 1);
  vector<vector<int>> dp(N+1, vector<int>(K+1, 0));

  for (int i = 1; i <= N; i++) {
    cin >> W >> V;
    bag[i].first = W;
    bag[i].second = V;
  }

  for (int i = 1; i <= N; i++) {
    for (int j = 1; j <= K; j++) {
      if (bag[i].first > j) {
        dp[i][j] = dp[i-1][j];
        continue;
      }


      dp[i][j] = max(dp[i-1][j], bag[i].second + dp[i-1][j - bag[i].first]);
    }
  }

  cout << dp[N][K] << "\n";




}
```

## Comment






---
# References