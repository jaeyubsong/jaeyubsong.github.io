---
title: 1520. 내리막길
date: 2023-01-28 03:31 +/-0900
categories: [PS, boj]
tags: [dfs, memoization, dynamic programming]     # TAG names should always be lowercase
---

# 1520. 내리막길

## Problem
[https://www.acmicpc.net/problem/1520](https://www.acmicpc.net/problem/1520){:target="_blank" rel="noopener"}

## Key Idea
- DFS를 사용하되, 메모이제이션을 통해서 이미 계산한 경로의 수를 다시 계산하지 말아라
- 메모이제이션을 사용하지 않으면 시간초과가 난다

## Algorithm
- dp\[M\]\[N\] 은 -1로 초기화하고, 좌표 (0,0) 부터 dfs 시작
- (i, j)에 대해서 dp\[j\]\[i\] 가 -1이 아니라면 이미 해당 좌표에서 오른쪽 아래 칸으로 가는 경로의 수를 계산한 것이므로 dp\[j\]\[i\]의 값 바로 반환
- dp\[j\]\[i\]가 -1이라면 갈수있는 방향 (상, 하, 좌, 우) 가 내리막인지 확인한 후, 내리막이면 dfs 실행하고 반환하는 경로의 수 합산
- 갈수있는 방향들에 대해서 dfs가 다 끝나면 합산한 후 dp\[j\]\[i\]에 저장

## Complexity
- Time Complexity: $$O(M * N)$$
- Space Complexity:  $$O(M * N*)$$

## Code
```c++
#include <iostream>
#include <vector>
#include <queue>
#include <utility>

using namespace std;

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

int dfs(int x, int y, vector<vector<int>>& map, int M, int N, vector<vector<int>>& dp) {
  if (dp[y][x] != -1) { return dp[y][x]; }

  int count{0};
  for (int i = 0; i < 4; i++) {
    int new_x = x + dx[i];
    int new_y = y + dy[i];
    if (new_x >= 0 && new_x < N && new_y >= 0 && new_y < M && map[new_y][new_x] < map[y][x]) {
      count += dfs(new_x, new_y, map, M, N, dp);
    }
  }

  dp[y][x] = count;
  return count;
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cout.tie(NULL);
  int M, N;
  cin >> M >> N;

  vector<vector<int>>map (M, vector<int>(N, 0));
  vector<vector<int>>dp (M, vector<int>(N, -1));
  dp[M-1][N-1] = 1;
  for (int i = 0; i < M; i++) {
    for (int j = 0; j < N; j++) {
      cin >> map[i][j];
    }
  }

  cout << dfs(0, 0, map, M, N, dp) << "\n";

  return 0;
  

}
```

## Comment






---
# References