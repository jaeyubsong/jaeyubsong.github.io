---
title: 1300. K번째 수
date: 2023-01-27 08:07 +/-0900
categories: [PS, boj]
tags: [binary search]     # TAG names should always be lowercase
---

# 1300. K번째 수

## Problem
[https://www.acmicpc.net/problem/1300](https://www.acmicpc.net/problem/1300){:target="_blank" rel="noopener"}

## Key Idea
- 이분 탐색을 이용한다

B\[x\] = v 일때, v를 찾는 방법
배열 B가 오름차순으로 정렬이 되어 있으므로, x는 v보다 작은 수의 개수보다는 무조건 크다.
x는 \(v보다 작은 수의 개수, v보다 작은 수의 개수 + v와 같은 수의 개수\] 이다.
위 조건을 만족하는 v를 찾으면 B\[x\] 값도 구할 수 있다

![Image Alt 텍스트]({{site.url}}/assets/img/postimg/boj1300_arr.png){:width="40%"}

예를 들면 k=20일때, 즉 B\[20\] 의 값을 구해본다고 하자. 처음에는 lo = 1, hi = 25로 두어서 A의 모든 배열을 탐색한다. mid = (lo + hi) / 2 로 두어서 B\[x\] = 12 일때, x의 값을 구한다
B\[x\] = 12
12보다 작거나 같은 수의 개수
- 1행: 5개 (cnt = 5)
- 2행: 5개 (cnt = 10)
- 3행: 4개 (cnt = 14)
- 4행: 3개 (cnt = 17)
- 5행: 2개 (cnt = 19)

따라서 B\[19\] = 12 이다. 우리가 구하고자 하는 k값보다 크므로, lo = mid - 1 로 두고, 위의 과정을 반복한다. 이때 주의해야 할 점은, B\[x\] = 12 에 대해서 x는 19보다 작을수는 있지만, 큰 경우는 없다. 따라서, 우리가 구하고자 하는 k값보다 만약 작은 인덱스 x'의 값을 구했다면, B\[x'\] = v' 인 v' 의 값이 B\[k\] 이 될 수도 있으므로, 저장을 해두어야 한다. 


## Algorithm

B\[x\] = v인 x의 값을 구하는 방법
- cnt = 0 으로 시작
- i = 1에서 i = N까지 실행
	- A\[i\]\[N\] 에서 v가 i \* N보다 같거나 크면, cnt에 N을 추가한다
	- i * *
- lo=1, hi=N\*N 으로 둔다
- A 배열의 가운데 (mid = (lo + hi) / 2) 에 있는 값을 v라고 두었을 때, B\[x\]=v인 x의 값을 구한다. 
- x가 k보다 크면, hi = mid-1 로 두고, 이분탐색을 다시 한다
- x가 k보다 작으면, lo = mid + 1로 두고, 이분탐색을 다시 한다


## Complexity
- Time Complexity: $$O(N log(K))$$
- Space Complexity:  $$O()$$

## Code
```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// num보다 같거나 작은 수의 개수 리턴
long long le_count(long long x, long long N) {
    long long cnt{0};
    for (long long i = 1; i <= N; i++) {
        cnt += min(N, x / i);
        if (i > x) { break; }
    }

    return cnt;

}


int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    long long N{};
    cin >> N;

    long long k;
    cin >> k;

    long long lo{1};
    long long hi{N * N};

    long long ans{0};

    while (lo <= hi) {
        long long mid{(lo + hi) / 2};
        long long le_cnt = le_count(mid, N);
        if (le_cnt < k) { // B[k]는 무조건 le_cnt보다 더 큼
            lo = mid + 1;
        } else { // B[k]는 le_cnt보다 작을수도, 아니면 같을 수 있음
            ans = mid;
            hi = mid - 1;
        }
    }

    cout << ans << "\n";
    return 0;
    

}

```

## Comment






---
# References